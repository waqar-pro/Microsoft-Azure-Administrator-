Lab 2: Azure Kubernetes Service (AKS) Deployment and Management
Objectives
By the end of this lab, students will be able to:

• Understand the fundamentals of Kubernetes and containerization • Set up and configure a local Kubernetes cluster using Minikube • Deploy multi-container applications to Kubernetes • Install and use Helm package manager for Kubernetes applications • Manage Kubernetes resources including pods, services, and deployments • Monitor and troubleshoot basic Kubernetes applications

Prerequisites
Before starting this lab, students should have:

• Basic understanding of Linux command line operations • Familiarity with Docker containers (helpful but not required) • Basic knowledge of YAML file structure • Understanding of web applications and networking concepts

Lab Environment Setup
Ready-to-Use Cloud Machines: Al Nafi provides Linux-based cloud machines with all necessary tools pre-installed. Simply click Start Lab to begin - no need to build your own VM or install additional software.

Your cloud machine includes: • Ubuntu Linux environment • Docker runtime • kubectl (Kubernetes command-line tool) • Minikube (local Kubernetes cluster) • Helm package manager • Text editors (nano, vim)

Task 1: Set up a Local Kubernetes Cluster
Subtask 1.1: Verify Environment and Start Minikube
First, let's verify that all required tools are available and start our local Kubernetes cluster.

Check Docker status:
sudo systemctl status docker
Verify kubectl installation:
kubectl version --client
Check Minikube installation:
minikube version
Start Minikube cluster:
minikube start --driver=docker
Verify cluster is running:
kubectl cluster-info
Check cluster nodes:
kubectl get nodes
Subtask 1.2: Explore Kubernetes Dashboard
Enable Minikube dashboard:
minikube dashboard --url
Open a new terminal and create a tunnel (keep this running):
kubectl proxy
Access the dashboard by opening the provided URL in your browser.
Subtask 1.3: Configure kubectl Context
View current context:
kubectl config current-context
List all contexts:
kubectl config get-contexts
View cluster information:
kubectl config view
Task 2: Deploy Multi-Container Applications and Integrate Helm
Subtask 2.1: Create a Simple Multi-Container Application
We'll deploy a web application with a frontend and backend component.

Create a project directory:
mkdir ~/k8s-lab
cd ~/k8s-lab
Create a namespace for our application:
kubectl create namespace webapp-demo
Create a backend deployment file:
cat > backend-deployment.yaml << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-app
  namespace: webapp-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: nginx:alpine
        ports:
        - containerPort: 80
        env:
        - name: APP_TYPE
          value: "backend"
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: webapp-demo
spec:
  selector:
    app: backend
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
EOF
Create a frontend deployment file:
cat > frontend-deployment.yaml << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-app
  namespace: webapp-demo
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: httpd:alpine
        ports:
        - containerPort: 80
        env:
        - name: BACKEND_URL
          value: "http://backend-service"
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: webapp-demo
spec:
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
    nodePort: 30080
  type: NodePort
EOF
Deploy the applications:
kubectl apply -f backend-deployment.yaml
kubectl apply -f frontend-deployment.yaml
Verify deployments:
kubectl get deployments -n webapp-demo
kubectl get pods -n webapp-demo
kubectl get services -n webapp-demo
Subtask 2.2: Test the Multi-Container Application
Get Minikube IP:
minikube ip
Test the frontend service:
curl http://$(minikube ip):30080
Check pod logs:
kubectl logs -n webapp-demo -l app=frontend
kubectl logs -n webapp-demo -l app=backend
Subtask 2.3: Install and Configure Helm
Verify Helm installation:
helm version
Add official Helm stable repository:
helm repo add stable https://charts.helm.sh/stable
helm repo add bitnami https://charts.bitnami.com/bitnami
Update Helm repositories:
helm repo update
List available repositories:
helm repo list
Subtask 2.4: Deploy Applications Using Helm
Search for available charts:
helm search repo nginx
Install an Nginx application using Helm:
helm install my-nginx bitnami/nginx --namespace webapp-demo
List Helm releases:
helm list -n webapp-demo
Check the deployed resources:
kubectl get all -n webapp-demo
Get service information:
kubectl get svc -n webapp-demo my-nginx
Subtask 2.5: Create a Custom Helm Chart
Create a new Helm chart:
helm create my-webapp
Explore the chart structure:
ls -la my-webapp/
cat my-webapp/Chart.yaml
Customize the values file:
cat > my-webapp/values.yaml << 'EOF'
replicaCount: 2

image:
  repository: nginx
  pullPolicy: IfNotPresent
  tag: "alpine"

service:
  type: NodePort
  port: 80
  nodePort: 30090

ingress:
  enabled: false

resources:
  limits:
    cpu: 100m
    memory: 128Mi
  requests:
    cpu: 100m
    memory: 128Mi
EOF
Install the custom chart:
helm install my-custom-app ./my-webapp --namespace webapp-demo
Verify the installation:
helm list -n webapp-demo
kubectl get pods -n webapp-demo
Subtask 2.6: Manage and Update Applications
Scale the backend deployment:
kubectl scale deployment backend-app --replicas=4 -n webapp-demo
Check the scaling:
kubectl get pods -n webapp-demo -l app=backend
Update a Helm release:
helm upgrade my-nginx bitnami/nginx --set replicaCount=3 --namespace webapp-demo
Check Helm release history:
helm history my-nginx -n webapp-demo
View resource usage:
kubectl top nodes
kubectl top pods -n webapp-demo
Subtask 2.7: Monitoring and Troubleshooting
Describe a pod for detailed information:
kubectl describe pod -n webapp-demo -l app=frontend
Check events in the namespace:
kubectl get events -n webapp-demo --sort-by='.lastTimestamp'
Execute commands inside a pod:
kubectl exec -it -n webapp-demo $(kubectl get pod -n webapp-demo -l app=frontend -o jsonpath='{.items[0].metadata.name}') -- /bin/sh
Exit the pod shell:
exit
Port forward to access a service locally:
kubectl port-forward -n webapp-demo svc/frontend-service 8080:80 &
Test the port forward:
curl http://localhost:8080
Stop the port forward:
pkill -f "kubectl port-forward"
Cleanup
Uninstall Helm releases:
helm uninstall my-nginx -n webapp-demo
helm uninstall my-custom-app -n webapp-demo
Delete the deployments:
kubectl delete -f frontend-deployment.yaml
kubectl delete -f backend-deployment.yaml
Delete the namespace:
kubectl delete namespace webapp-demo
Stop Minikube (optional):
minikube stop
Troubleshooting Tips
Common Issues and Solutions:

• Pods stuck in Pending state: Check resource availability with kubectl describe pod <pod-name> • Service not accessible: Verify service endpoints with kubectl get endpoints • Helm installation fails: Check repository updates with helm repo update • Minikube won't start: Try minikube delete and minikube start to reset • Permission denied errors: Ensure Docker daemon is running and user has proper permissions

Useful Commands for Debugging:

# Check cluster status
kubectl get componentstatuses

# View all resources in a namespace
kubectl get all -n <namespace>

# Get detailed pod information
kubectl describe pod <pod-name> -n <namespace>

# Check logs from multiple pods
kubectl logs -f -l app=<app-label> -n <namespace>
Conclusion
In this lab, you have successfully:

• Set up a local Kubernetes cluster using Minikube • Deployed multi-container applications with proper service communication • Learned to use Helm package manager for application deployment • Created and customized Helm charts for application management • Practiced scaling, updating, and monitoring Kubernetes applications • Gained hands-on experience with kubectl commands and Kubernetes resources

Why This Matters: Kubernetes is the industry standard for container orchestration, and understanding how to deploy and manage applications in Kubernetes environments is crucial for modern software development and DevOps practices. The skills learned in this lab form the foundation for working with production Kubernetes clusters, including managed services like Azure Kubernetes Service (AKS), Amazon EKS, and Google GKE.

This knowledge prepares you for real-world scenarios where you'll need to deploy, scale, and maintain containerized applications in cloud environments, making you valuable in today's technology landscape.

